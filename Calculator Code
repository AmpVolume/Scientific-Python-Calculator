import tkinter as tk
from tkinter import messagebox
import math
import re

# Custom math functions
def root(x, n):
    return x ** (1 / n)

def logn(x, base):
    return math.log(x, base)

class ScientificCalculator:
    def __init__(self, root):
        self.root = root
        self.root.title("Scientific Calculator")
        self.expression = ""
        self.history = []
        self.mode = "DEG"
        self.last_answer = "0"
        self.memory = 0
        self.theme = "dark"

        self.set_theme()

        self.number_font = ("Courier New", 16, "bold")

        self.entry = tk.Text(root, width=40, height=2, font=("Courier New", 16), insertbackground="white")
        self.entry.grid(row=0, column=0, columnspan=6, padx=10, pady=10)
        self.entry.bind("<KeyRelease>", self.highlight_syntax)

        self.create_buttons()

    def set_theme(self):
        if self.theme == "dark":
            bg = "black"
            fg = "white"
        else:
            bg = "white"
            fg = "black"

        self.root.configure(bg=bg)
        if hasattr(self, 'entry'):
            self.entry.configure(bg=bg, fg=fg, insertbackground=fg)
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Button):
                widget.configure(bg="gray20" if self.theme == "dark" else "lightgray", fg=fg)

    def toggle_theme(self):
        self.theme = "light" if self.theme == "dark" else "dark"
        self.set_theme()
        self.highlight_syntax()

    def add_to_expression(self, value):
        self.entry.insert(tk.END, str(value))
        self.highlight_syntax()

    def clear_expression(self):
        self.entry.delete("1.0", tk.END)

    def delete_last(self):
        content = self.entry.get("1.0", tk.END)[:-2]
        self.entry.delete("1.0", tk.END)
        self.entry.insert(tk.END, content)
        self.highlight_syntax()

    def update_entry(self):
        self.entry.delete("1.0", tk.END)
        self.entry.insert(tk.END, self.expression)
        self.highlight_syntax()

    def balance_parentheses(self, expr):
        open_parens = expr.count('(')
        close_parens = expr.count(')')
        return expr + (')' * (open_parens - close_parens))

    def calculate(self):
        try:
            self.expression = self.entry.get("1.0", tk.END).strip()
            expr = self.expression.replace("^", "**")
            expr = expr.replace("\u221a", "root(")
            expr = expr.replace("ANS", self.last_answer)

            if self.mode == "DEG":
                expr = expr.replace("sin(", "math.sin(math.radians(")
                expr = expr.replace("cos(", "math.cos(math.radians(")
                expr = expr.replace("tan(", "math.tan(math.radians(")
                expr = expr.replace("asin(", "math.degrees(math.asin(")
                expr = expr.replace("acos(", "math.degrees(math.acos(")
                expr = expr.replace("atan(", "math.degrees(math.atan(")
            else:
                expr = expr.replace("sin(", "math.sin(")
                expr = expr.replace("cos(", "math.cos(")
                expr = expr.replace("tan(", "math.tan(")
                expr = expr.replace("asin(", "math.asin(")
                expr = expr.replace("acos(", "math.acos(")
                expr = expr.replace("atan(", "math.atan(")

            expr = expr.replace("sinh(", "math.sinh(")
            expr = expr.replace("cosh(", "math.cosh(")
            expr = expr.replace("tanh(", "math.tanh(")
            expr = expr.replace("log(", "math.log(")
            expr = expr.replace("sqrt(", "math.sqrt(")
            expr = expr.replace("exp(", "math.exp(")
            expr = expr.replace("pi", str(math.pi))
            expr = expr.replace("e", str(math.e))
            expr = expr.replace("logn(", "logn(")
            expr = expr.replace("root(", "root(")

            expr = self.balance_parentheses(expr)

            result = eval(expr, {"__builtins__": {}}, {
                "math": math, "root": root, "logn": logn
            })

            self.last_answer = str(result)
            self.history.append(f"{self.expression} = {result}")
            self.expression = str(result)
            self.update_entry()
        except Exception as e:
            self.entry.tag_add("error", "1.0", tk.END)
            self.entry.tag_config("error", background="darkred")
            messagebox.showerror("Error", f"Invalid Expression\n{e}")

    def toggle_mode(self):
        self.mode = "RAD" if self.mode == "DEG" else "DEG"
        messagebox.showinfo("Mode Toggled", f"Switched to {self.mode} mode")

    def show_history(self):
        history_text = "\n".join(self.history[-10:] or ["No history yet."])
        messagebox.showinfo("History", history_text)

    def memory_add(self):
        try:
            self.memory += float(self.entry.get("1.0", tk.END).strip())
        except:
            messagebox.showerror("Error", "Invalid number for M+")

    def memory_subtract(self):
        try:
            self.memory -= float(self.entry.get("1.0", tk.END).strip())
        except:
            messagebox.showerror("Error", "Invalid number for M-")

    def memory_recall(self):
        self.add_to_expression(str(self.memory))

    def memory_clear(self):
        self.memory = 0

    def highlight_syntax(self, event=None):
        self.entry.tag_remove("highlight", "1.0", tk.END)
        self.entry.tag_remove("number", "1.0", tk.END)
        self.entry.tag_remove("operator", "1.0", tk.END)
        self.entry.tag_remove("error", "1.0", tk.END)

        content = self.entry.get("1.0", tk.END)
        keywords = ["sin", "cos", "tan", "log", "sqrt", "exp", "pi", "e", "ANS", "root", "logn"]
        for word in keywords:
            idx = "1.0"
            while True:
                idx = self.entry.search(word, idx, nocase=False, stopindex=tk.END)
                if not idx:
                    break
                end_idx = f"{idx}+{len(word)}c"
                self.entry.tag_add("highlight", idx, end_idx)
                idx = end_idx

        for match in re.finditer(r"\b\d+(\.\d+)?\b", content):
            start = f"1.0+{match.start()}c"
            end = f"1.0+{match.end()}c"
            self.entry.tag_add("number", start, end)

        for match in re.finditer(r"[\^\*\+/\-%=]", content):
            start = f"1.0+{match.start()}c"
            end = f"1.0+{match.end()}c"
            self.entry.tag_add("operator", start, end)

        self.entry.tag_config("highlight", foreground="blue")
        self.entry.tag_config("number", foreground="#006400", font=self.number_font)
        self.entry.tag_config("operator", foreground="red")
        self.entry.tag_config("error", background="darkred")

    def create_buttons(self):
        buttons = [
            ("7", 1, 0), ("8", 1, 1), ("9", 1, 2), ("/", 1, 3), ("sin(", 1, 4), ("asin(", 1, 5),
            ("4", 2, 0), ("5", 2, 1), ("6", 2, 2), ("*", 2, 3), ("cos(", 2, 4), ("acos(", 2, 5),
            ("1", 3, 0), ("2", 3, 1), ("3", 3, 2), ("-", 3, 3), ("tan(", 3, 4), ("atan(", 3, 5),
            ("0", 4, 0), (".", 4, 1), ("+", 4, 2), ("^", 4, 3), ("sqrt(", 4, 4), ("%", 4, 5),
            ("log(", 5, 0), ("exp(", 5, 1), ("pi", 5, 2), ("e", 5, 3), ("(", 5, 4), (")", 5, 5),
            ("sinh(", 6, 0), ("cosh(", 6, 1), ("tanh(", 6, 2), ("logn(", 6, 3), ("root(", 6, 4), ("ANS", 6, 5),
            ("M+", 7, 0), ("M-", 7, 1), ("MR", 7, 2), ("MC", 7, 3), ("HIST", 7, 4), ("MODE", 7, 5),
            ("C", 8, 0), ("DEL", 8, 1), ("=", 8, 2), ("THEME", 8, 3)
        ]

        for (text, row, col) in buttons:
            action = lambda x=text: self.handle_button(x)
            tk.Button(self.root, text=text, width=6, height=2, command=action).grid(row=row, column=col, padx=2, pady=2)

    def handle_button(self, label):
        if label == "=":
            self.calculate()
        elif label == "C":
            self.clear_expression()
        elif label == "DEL":
            self.delete_last()
        elif label == "HIST":
            self.show_history()
        elif label == "MODE":
            self.toggle_mode()
        elif label == "THEME":
            self.toggle_theme()
        elif label == "M+":
            self.memory_add()
        elif label == "M-":
            self.memory_subtract()
        elif label == "MR":
            self.memory_recall()
        elif label == "MC":
            self.memory_clear()
        else:
            self.add_to_expression(label)

if __name__ == "__main__":
    root = tk.Tk()
    calc = ScientificCalculator(root)
    root.mainloop()
